{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "555ee346-b84c-465b-ae52-d82a180254c3",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2025-09-08 16:43:02.673 WARNING streamlit.runtime.scriptrunner_utils.script_run_context: Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:02.675 WARNING streamlit.runtime.state.session_state_proxy: Session state does not function when running a script without `streamlit run`\n",
      "2025-09-08 16:43:02.676 WARNING streamlit.runtime.scriptrunner_utils.script_run_context: Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:02.677 WARNING streamlit.runtime.scriptrunner_utils.script_run_context: Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:02.677 WARNING streamlit.runtime.scriptrunner_utils.script_run_context: Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:02.678 WARNING streamlit.runtime.scriptrunner_utils.script_run_context: Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:03.623 \n",
      "  \u001b[33m\u001b[1mWarning:\u001b[0m to view this Streamlit app on a browser, run it with the following\n",
      "  command:\n",
      "\n",
      "    streamlit run C:\\Users\\09403415\\AppData\\Local\\anaconda3\\Lib\\site-packages\\ipykernel_launcher.py [ARGUMENTS]\n",
      "2025-09-08 16:43:03.624 Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:03.625 Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:03.625 Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:03.626 Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:03.626 Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:03.626 Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:03.627 Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:03.627 Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:03.627 Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:03.628 Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:03.628 Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:03.628 Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:03.629 Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:03.629 Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:03.630 Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:03.630 Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:03.631 Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n",
      "2025-09-08 16:43:03.631 Thread 'MainThread': missing ScriptRunContext! This warning can be ignored when running in bare mode.\n"
     ]
    }
   ],
   "source": [
    "import streamlit as st\n",
    "import pandas as pd\n",
    "from io import StringIO, BytesIO\n",
    "from scipy.optimize import curve_fit\n",
    "from sklearn.metrics import r2_score  # 決定係数計算用\n",
    "import matplotlib.pyplot as plt\n",
    "import statsmodels.api as sm\n",
    "import statsmodels.formula.api as smf\n",
    "\n",
    "# ユーザーデータの作成（実際には安全な方法で保存する必要があります）\n",
    "user_data = {\n",
    "    'yomiko_mcc':'admin4035',\n",
    "    'user1': 'password1',\n",
    "    'user2': 'password2',\n",
    "    # 他のユーザー情報\n",
    "}\n",
    "\n",
    "def func_fit(x, a, b, K):\n",
    "    y = K / (1 + (a * x ** b))\n",
    "    return y\n",
    "\n",
    "def convert_df(df):\n",
    "    return df.to_csv().encode('utf-8')\n",
    "\n",
    "def download(df):\n",
    "    df = convert_df(df)\n",
    "    st.download_button(\n",
    "        label=\"Download data as CSV\",\n",
    "        data=df,\n",
    "        file_name='output.csv',\n",
    "        mime='text/csv',\n",
    "    )\n",
    "\n",
    "# Excelデータ作成関数\n",
    "def create_excel_file():\n",
    "    output = BytesIO()  # メモリ上にバイナリデータを格納\n",
    "    with pd.ExcelWriter(output, engine='openpyxl') as writer:\n",
    "        fin_data.to_excel(writer, sheet_name='program×brand', index=True)\n",
    "        allocated_program_data.to_excel(writer, sheet_name='allocated_program_data', index=True)\n",
    "        view_track.to_excel(writer, sheet_name='view_track', index=True)\n",
    "        fin_view_rate_list.to_excel(writer, sheet_name='fin_view_rate_list', index=True)\n",
    "        allocated_brand_data.to_excel(writer, sheet_name='allocated_brand_cost', index=True)\n",
    "    output.seek(0)  # ファイルポインタを先頭に戻す\n",
    "    return output\n",
    "\n",
    "def login():\n",
    "    if 'logged_in' not in st.session_state:\n",
    "        st.session_state.logged_in = False\n",
    "\n",
    "    if st.session_state.logged_in:\n",
    "        return True\n",
    "\n",
    "    st.title(\"ログイン\")\n",
    "    username = st.text_input(\"ユーザー名\")\n",
    "    password = st.text_input(\"パスワード\", type='password')\n",
    "\n",
    "    if st.button(\"ログイン\"):\n",
    "        if username in user_data and user_data[username] == password:\n",
    "            st.session_state.logged_in = True\n",
    "            st.session_state.username = username  # ユーザー名をセッション状態に保存\n",
    "            st.experimental_rerun()  # ページをリロードしてメインページに移動\n",
    "        else:\n",
    "            st.error(\"ユーザー名またはパスワードが正しくありません。\")\n",
    "    return False\n",
    "\n",
    "def tab1():\n",
    "    st.write(\"Cuerve数式予測\")\n",
    "    st.subheader(\"目的\")\n",
    "    text_11=\"\"\"\n",
    "    - 目的変数（出稿量や予算）に対する説明変数（リーチや認知）の曲線を作成する。\"\"\"\n",
    "    st.markdown(text_11)\n",
    "    st.subheader(\"使用ケース\")\n",
    "    text_12=\"\"\"\n",
    "    - **出稿量（予算）とリーチの関係分析**: 広告出稿量の増加に対して、どの程度リーチが増加するかを予測。\n",
    "    - **出稿量（予算）と認知度の関係分析**: 広告出稿量が増加に対して、どの程度認知度が上昇するかを予測。\"\"\"\n",
    "    st.markdown(text_12)\n",
    "    st.subheader(\"inputデータ\")\n",
    "    text_13=\"\"\"\n",
    "    - 目的変数となる値とそれに伴う説明変数を入力。\"\"\"\n",
    "    if st.button(\"Click me to go to folder\"):\n",
    "        st.write('[Go to folder](https://hakuhodody-my.sharepoint.com/:f:/r/personal/sd000905_hakuhodody-holdings_co_jp/Documents/%E7%B5%B1%E5%90%88AP%E5%B1%80_AaaS1-4%E9%83%A8_%E5%85%B1%E6%9C%89OneDrive/04.%20%E3%83%84%E3%83%BC%E3%83%AB%EF%BC%8F%E3%82%BD%E3%83%AA%E3%83%A5%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3/megupy/01.input?csf=1&web=1&e=waFpBB)')\n",
    "    st.markdown(text_13)\n",
    "    st.subheader(\"アウトプット説明\")\n",
    "    st.markdown(\"- モデルの数式\")\n",
    "    st.latex(r\"\"\"\n",
    "    y = \\frac{K}{1 + \\left(a \\left(\\frac{x}{10^{dx}}\\right)^b\\right)} \\cdot 10^{dy}\n",
    "    \"\"\")\n",
    "    text_14=\"\"\"\n",
    "    - 「dx」「dy」は桁数を揃えるための数値。\n",
    "    - 出力された、「a」「b」「K」「dx」「dy」を上記式に代入。\n",
    "    - Number of decisions（決定係数, R²）: モデルの適合度を示す。1に近い程モデルがデータにフィットしていることを意味する。\"\"\"\n",
    "    st.markdown(text_14)\n",
    "\n",
    "\n",
    "\n",
    "\n",
    "    uploaded_file = st.file_uploader(\"Curve数式予測用inputファイルをアップロードしてください\", type=[\"csv\", \"xlsx\"])\n",
    "\n",
    "    if uploaded_file is not None:\n",
    "        try:\n",
    "            st.write(\"アップロードされたファイルの中身:\")\n",
    "            if uploaded_file.type == \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\":\n",
    "                bytes_data = uploaded_file.read()\n",
    "                xl = pd.ExcelFile(BytesIO(bytes_data))\n",
    "                # シート名が \"A_入力\" の場合のみ読み込む\n",
    "                if \"A_入力\" in xl.sheet_names:\n",
    "                    df = pd.read_excel(xl, sheet_name=\"A_入力\")\n",
    "                    st.write(df)\n",
    "                else:\n",
    "                    st.warning(\"指定されたシートが見つかりませんでした。\")\n",
    "            else:\n",
    "                stringio = StringIO(uploaded_file.getvalue().decode(\"utf-8\"))\n",
    "                df = pd.read_csv(stringio, encoding=\"shift-jis\")\n",
    "                st.write(df)\n",
    "\n",
    "            num = int(df.shape[1] / 2)\n",
    "            for i in range(num):\n",
    "                df_temp = df.iloc[:, [i * 2, i * 2 + 1]]\n",
    "                df_temp.dropna()\n",
    "\n",
    "            st.write(df)  # 一旦読み込んだデータのNaNを削除して表示\n",
    "\n",
    "            name_list = []\n",
    "            a_list = []\n",
    "            b_list = []\n",
    "            K_list = []\n",
    "            R_list = []\n",
    "            d_x_list = []\n",
    "            d_y_list = []\n",
    "\n",
    "            max_fev = 100000000\n",
    "            df2 = pd.DataFrame()\n",
    "\n",
    "            for i in range(num):\n",
    "                df_temp = df.iloc[:, [i * 2, i * 2 + 1]]\n",
    "                df_temp = df_temp.dropna()\n",
    "\n",
    "                x_observed = df_temp.iloc[:, 0]\n",
    "                y = df_temp.iloc[:, 1]\n",
    "\n",
    "                # 説明変数と目的変数の桁数を計算する\n",
    "                max_num = max(x_observed)\n",
    "                s_x = str(max_num)\n",
    "                if '.' in s_x:\n",
    "                    s_x_i, s_x_d = s_x.split('.')\n",
    "                else:\n",
    "                    s_x_i = s_x\n",
    "                    s_x_d = '0'\n",
    "                d_x = float(len(s_x_i))\n",
    "\n",
    "                max_num = max(y)\n",
    "                s_y = str(max_num)\n",
    "                s_y_i, s_y_d = s_y.split('.')\n",
    "                d_y = float(len(s_y_i))\n",
    "\n",
    "                x_observed = x_observed / 10 ** d_x\n",
    "                y = y / 10 ** d_y\n",
    "                max_num = max(y) * 10\n",
    "\n",
    "                bounds = ((0, -5, 0), (100, 0, max_num))\n",
    "                # bounds = ((0,-3,0),(10000000,0,50000))\n",
    "\n",
    "                name = df.columns.values[i * 2]\n",
    "                param, pcov = curve_fit(func_fit, x_observed, y, bounds=bounds, maxfev=max_fev)\n",
    "                fit_y = func_fit(x_observed, param[0], param[1], param[2])\n",
    "                df2[name + \"_x\"] = x_observed * 10 ** d_x\n",
    "                df2[name + \"_y\"] = y * 10 ** d_y\n",
    "                df2[name + \"_fit\"] = fit_y * 10 ** d_y\n",
    "                R2 = r2_score(fit_y, y)\n",
    "\n",
    "                name_list.append(name)\n",
    "                a_list.append(param[0])\n",
    "                b_list.append(param[1])\n",
    "                K_list.append(param[2])\n",
    "                d_x_list.append(d_x)\n",
    "                d_y_list.append(d_y)\n",
    "                R_list.append(R2)\n",
    "\n",
    "            df_param = pd.DataFrame({\"name\": name_list, \"a\": a_list, \"b\": b_list, \"max_value\": K_list,\n",
    "                                     \"d_x\": d_x_list, \"d_y\": d_y_list, \"R2\": R_list})\n",
    "            st.write(df_param)  # 一旦読み込んだデータのNaNを削除したよ\n",
    "            download(df_param)\n",
    "\n",
    "            # プルダウンによるグラフ表示\n",
    "            selected_name = st.selectbox(\"グラフ化するデータを選択してください\", df_param['name'].unique())\n",
    "            if selected_name:\n",
    "                plt.figure(figsize=(10, 6))\n",
    "                plt.scatter(df2[selected_name + \"_x\"], df2[selected_name + \"_y\"], label=\"Data\")\n",
    "                plt.plot(df2[selected_name + \"_x\"], df2[selected_name + \"_fit\"], 'r-', label=\"Fit\")\n",
    "                plt.xlabel(\"X\")\n",
    "                plt.ylabel(\"Y\")\n",
    "                plt.title(f\"Fit for {selected_name}\")\n",
    "                plt.legend()\n",
    "                st.pyplot(plt)\n",
    "\n",
    "        except Exception as e:\n",
    "            st.error(f\"ファイルを読み込む際にエラーが発生しました: {e}\")\n",
    "\n",
    "def tab2():\n",
    "    st.write(\"STL分解\")\n",
    "    st.subheader(\"目的\")\n",
    "    text_21=\"\"\"\n",
    "    - 時系列データをトレンド、季節成分、残差に分解することにより、データの特性を把握する。\"\"\"\n",
    "    st.markdown(text_21)\n",
    "    st.subheader(\"使用ケース\")\n",
    "    text_22=\"\"\"\n",
    "    - GoogleトレンドやDS.INSIGHTなどからKWボリュームの過去傾向を分析し、季節性や長期トレンドを確認。\"\"\"\n",
    "    st.markdown(text_22)\n",
    "    st.subheader(\"inputデータ\")\n",
    "    text_23=\"\"\"\n",
    "    - 時系列での、期間とKWボリュームを入力。\"\"\"\n",
    "    if st.button(\"Click me to go to folder\"):\n",
    "        st.write('[Go to folder](https://hakuhodody-my.sharepoint.com/:f:/r/personal/sd000905_hakuhodody-holdings_co_jp/Documents/%E7%B5%B1%E5%90%88AP%E5%B1%80_AaaS1-4%E9%83%A8_%E5%85%B1%E6%9C%89OneDrive/04.%20%E3%83%84%E3%83%BC%E3%83%AB%EF%BC%8F%E3%82%BD%E3%83%AA%E3%83%A5%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3/megupy/01.input?csf=1&web=1&e=waFpBB)')\n",
    "    st.markdown(text_23)\n",
    "    st.subheader(\"アウトプット説明\")\n",
    "    text_24=\"\"\"\n",
    "    - **_raw**: 元の時系列データ\n",
    "    - **_trend**: トレンド成分\n",
    "    - **_seasonal**: 季節成分\n",
    "    - **_resid**: 残差成分（トレンド&季節成分を除去した後のデータ）\"\"\"\n",
    "    st.markdown(text_24)\n",
    "    text_25=\"\"\"\n",
    "    - GoogleトレンドやDS.INSIGHTなどからKWボリュームの過去傾向を分析し、季節性や長期トレンドを確認。週別のデータも、月別のデータでもコードが判断してくれるので、どちらのケースでも使用可能。\"\"\"\n",
    "    st.markdown(text_25)\n",
    "\n",
    "\n",
    "    if 'uploaded_file_tab2' not in st.session_state:\n",
    "        st.session_state.uploaded_file_tab2 = None\n",
    "\n",
    "    uploaded_file = st.file_uploader(\"STL分解用inputファイルをアップロードしてください\", type=[\"csv\", \"xlsx\"], key='tab2_uploader')\n",
    "\n",
    "    if uploaded_file is not None:\n",
    "        st.session_state.uploaded_file_tab2 = uploaded_file\n",
    "        try:\n",
    "            if uploaded_file.name.endswith(\"csv\"):\n",
    "                df = pd.read_csv(uploaded_file)\n",
    "            elif uploaded_file.name.endswith(\"xlsx\"):\n",
    "                df = pd.read_excel(uploaded_file)\n",
    "            \n",
    "            st.write(\"データプレビュー:\")\n",
    "            st.write(df.head())\n",
    "\n",
    "            period_num = (df.iat[1, 0] - df.iat[0, 0]).days\n",
    "            data_num = df.shape[1] - 1\n",
    "            df_date = df.iloc[:, 0]\n",
    "            df = df.set_index(\"date\")\n",
    "            df.head()\n",
    "\n",
    "            ##■周期の設定##\n",
    "            if period_num > 7:\n",
    "                period = 12\n",
    "            elif period_num == 7:\n",
    "                period = 52\n",
    "            elif period_num == 1:\n",
    "                period = 365\n",
    "            else:\n",
    "                period = 0\n",
    "                print(\"任意の期間を設定してください。\")\n",
    "\n",
    "            print(period)\n",
    "\n",
    "            ##■分解##\n",
    "            result = pd.DataFrame()\n",
    "\n",
    "            # DataFrame内の各列に対してループ処理\n",
    "            for i in range(data_num):\n",
    "                stl = sm.tsa.seasonal_decompose(df.iloc[:, i], period=period)\n",
    "                name = df.columns.values[i]\n",
    "\n",
    "                tmp = pd.DataFrame()\n",
    "                tmp[str(name) + \"_raw\"] = df.iloc[:, i]\n",
    "                tmp[str(name) + \"_trend\"] = stl.trend\n",
    "                tmp[str(name) + \"_seasonal\"] = stl.seasonal\n",
    "                tmp[str(name) + \"_resid\"] = stl.resid\n",
    "\n",
    "                result = pd.concat([result, tmp], axis=1)\n",
    "\n",
    "                # それぞれの系列ごとに独立したグラフを生成する\n",
    "                fig, ax = plt.subplots()\n",
    "                for column in tmp.columns:\n",
    "                    if \"_raw\" in column or \"_trend\" in column or \"_seasonal\" in column:\n",
    "                        ax.plot(df.index, tmp[column], label=column)  # DataFrame の index を X軸に使用してプロット\n",
    "\n",
    "                ax.set_xlabel('Date')\n",
    "                ax.set_ylabel('Value')\n",
    "                ax.set_title('Decomposition of ' + str(name))  # グラフタイトル\n",
    "                ax.legend()\n",
    "\n",
    "                st.pyplot(fig)  # グラフを表示\n",
    "\n",
    "            st.write(result)\n",
    "            download(result)\n",
    "\n",
    "        except Exception as e:\n",
    "            st.error(f\"ファイルを読み込む際にエラーが発生しました: {e}\")\n",
    "\n",
    "\n",
    "def tab3():\n",
    "    st.write(\"Logistic回帰\")\n",
    "\n",
    "    st.subheader(\"目的\")\n",
    "    text_31=\"\"\"\n",
    "    - ある特定の事象が起きる確率を分析し、結果を予測する。\"\"\"\n",
    "    st.markdown(text_31)\n",
    "    st.subheader(\"使用ケース\")\n",
    "    text_32=\"\"\"\n",
    "    - 調査結果の個票データ解析: 説明変数として各メディアの接触有無（0,1データ）、目的変数として認知などのKPI有無（0,1データ）を使用して、各メディアの接触がKPIに与える影響を定量化する。GoogleトレンドやDS.INSIGHTなどからKWボリュームの過去傾向を分析し、季節性や長期トレンドを確認。\n",
    "    - CV起点でのCP評価: IDベースに、CPごとにFQしたかどうかを説明変数として（0,1データ）、ある指定期間内にCVしたかどうかを目的変数としたときに（0,1データ）、過去蓄積効果があったのか確認する。\"\"\"\n",
    "    st.markdown(text_32)\n",
    "    st.subheader(\"inputデータ\")\n",
    "    text_33=\"\"\"\n",
    "    - 目的変数となる値とそれに伴う説明変数を入力。\"\"\"\n",
    "    if st.button(\"Click me to go to folder\"):\n",
    "        st.write('[Go to folder](https://hakuhodody-my.sharepoint.com/:f:/r/personal/sd000905_hakuhodody-holdings_co_jp/Documents/%E7%B5%B1%E5%90%88AP%E5%B1%80_AaaS1-4%E9%83%A8_%E5%85%B1%E6%9C%89OneDrive/04.%20%E3%83%84%E3%83%BC%E3%83%AB%EF%BC%8F%E3%82%BD%E3%83%AA%E3%83%A5%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3/megupy/01.input?csf=1&web=1&e=waFpBB)')\n",
    "    st.markdown(text_33)\n",
    "    st.subheader(\"アウトプット説明\")\n",
    "    text_34=\"\"\"\n",
    "    - **★importance**: 説明変数（各メディア接触有無）が目的変数（KPI）に与える貢献度をはかるための指標。\n",
    "    - **odds**: オッズ比。importanceと大小関係は基本同じ。1より大きいならKPIに対して＋に働く1よりい低いなら－に働く。\n",
    "    - P>|z|：P値。有意水準0.05を下回ればその説明変数は有意な偏回帰係数であることが言える。\"\"\"\n",
    "    st.markdown(text_34)\n",
    "    text_35=\"\"\"\n",
    "    - inputデータの目的変数と説明変数の入力位置に注意。\"\"\"\n",
    "    st.markdown(text_35)\n",
    "\n",
    "    uploaded_file = st.file_uploader(\"ファイルをアップロードしてください\", type=[\"csv\", \"xlsx\"])\n",
    "\n",
    "    if uploaded_file is not None:\n",
    "        try:\n",
    "            st.write(\"アップロードされたファイルの中身:\")\n",
    "            if uploaded_file.type == \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\":\n",
    "                bytes_data = uploaded_file.read()\n",
    "                df = pd.read_excel(BytesIO(bytes_data))\n",
    "            else:\n",
    "                stringio = StringIO(uploaded_file.getvalue().decode(\"utf-8\"))\n",
    "                df = pd.read_csv(stringio, encoding=\"shift-jis\")\n",
    "\n",
    "            st.write(df)\n",
    "\n",
    "            num = df.shape[1]-2\n",
    "            formula = df.columns.values[1] + \"~\"\n",
    "            print(num)\n",
    "            name_list = []\n",
    "            for i in range(num):\n",
    "                columns = df.columns.values[i+2]\n",
    "                formula = formula + \"+\" + columns\n",
    "                name_list.append(columns)\n",
    "\n",
    "            #ロジスティック回帰モデルの推定\n",
    "            logistic = smf.glm(formula = formula,data = df,family = sm.families.Binomial()).fit()\n",
    "\n",
    "            df_dict = pd.DataFrame()\n",
    "\n",
    "            #予測\n",
    "            for i in range(num):\n",
    "                num_list = []\n",
    "                for j in range(num):\n",
    "                    if i == j:\n",
    "                        list_num = 1\n",
    "                    else:\n",
    "                        list_num = 0\n",
    "                \n",
    "                    num_list.append(list_num)\n",
    "                    \n",
    "                df_dict[name_list[i]] = num_list\n",
    "                \n",
    "            #予測値出力\n",
    "            pred = logistic.predict(df_dict)\n",
    "            print(pred)\n",
    "            st.write(df_dict.head())\n",
    "\n",
    "            import scipy as sp\n",
    "\n",
    "            media_list = []\n",
    "            # param_list = []\n",
    "            odds_list = []\n",
    "            p_values_list = []\n",
    "\n",
    "            for i in name_list:\n",
    "                media_list.append(i)\n",
    "                odds_list.append(sp.exp(logistic.params[i]))\n",
    "                p_values_list.append(logistic.pvalues[i])\n",
    "\n",
    "            df_odds = pd.DataFrame({\"media\":media_list,\"importance\":pred,\"odds\":odds_list,\"p_values\": p_values_list})\n",
    "            st.write(df_odds.head())\n",
    "            download(df_odds)\n",
    "\n",
    "\n",
    "        except Exception as e:\n",
    "            st.error(f\"ファイルを読み込む際にエラーが発生しました: {e}\")\n",
    "\n",
    "def tab4():\n",
    "    st.write(\"TIME最適化\")\n",
    "\n",
    "    st.subheader(\"目的\")\n",
    "    text_41=\"\"\"\n",
    "    - TIMEの複数素材割り付けを最適化\"\"\"\n",
    "    st.markdown(text_41)\n",
    "    st.subheader(\"使用ケース\")\n",
    "    text_42=\"\"\"\n",
    "    - 複数ブランドをTIMEで放映する場合\n",
    "    - レギュラータイム/FTB/単発タイムなど固定の枠がある場合\"\"\"\n",
    "    st.markdown(text_42)\n",
    "    st.subheader(\"inputデータ\")\n",
    "    text_43=\"\"\"\n",
    "    - A-Dシートをそれぞれ入力\"\"\"\n",
    "    if st.button(\"Click me to go to folder\"):\n",
    "        st.write('[Go to folder](https://hakuhodody.sharepoint.com/:f:/s/msteams_d8fd35/Eu6cDQ4W-t5KlsMGSjLhfQQBaYubS13B_Ge2FzODeaZO-A?e=lvq7tE)')\n",
    "    st.markdown(text_43)\n",
    "    st.subheader(\"アウトプット説明\")\n",
    "    text_44=\"\"\"\n",
    "    - ブランドごとの最適な番組フォーメーション\n",
    "    - 番組追加による累積リーチ\n",
    "    - 最適化後のブランドごとの予算\"\"\"\n",
    "    st.markdown(text_44)\n",
    "    text_45=\"\"\"\n",
    "    - AシートとCシートの番組IDは漏れなくダブりなく\"\"\"\n",
    "    st.markdown(text_45)\n",
    "\n",
    "    # タイトル\n",
    "    st.title(\"モード選択\")\n",
    "\n",
    "    # プルダウン選択肢\n",
    "    options = [\"reach cost\", \"reach\", \"target_cost\"]\n",
    "    mode = st.selectbox(\"モードを選択してください\", options, index=2)  # indexでデフォルト選択\n",
    "\n",
    "    # アップロードされたファイルがあるか確認\n",
    "    if \"uploaded_file\" not in st.session_state:\n",
    "        st.session_state[\"uploaded_file\"] = None\n",
    "\n",
    "    # ファイルアップロード\n",
    "    uploaded_file = st.file_uploader(\"Excelファイルをアップロードしてください\", type=[\"xlsx\"])\n",
    "\n",
    "    if uploaded_file is not None:\n",
    "        try:\n",
    "            st.write(\"アップロードされたファイルの中身を読み込み中...\")\n",
    "            # Excelファイルの全シートを取得\n",
    "            if uploaded_file.type == \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\":\n",
    "                bytes_data = uploaded_file.read()\n",
    "                sheets = pd.read_excel(BytesIO(bytes_data), sheet_name=None)\n",
    "\n",
    "                # 各シートを取得\n",
    "                limit_data = sheets['A_Limit'].set_index(['Program_code', 'date'])\n",
    "                brand_data = sheets['B_Brand'].set_index('Brand')\n",
    "                view_data = sheets['C_View'].set_index('Sample')\n",
    "                target_data = sheets['D_Target'].set_index('Brand')\n",
    "\n",
    "                # 確認のためデータを表示\n",
    "                st.write(\"### A_Limit シートのデータ\")\n",
    "                st.dataframe(limit_data.head())\n",
    "\n",
    "                st.write(\"### B_Brand シートのデータ\")\n",
    "                st.dataframe(brand_data.head())\n",
    "\n",
    "                st.write(\"### C_View シートのデータ\")\n",
    "                st.dataframe(view_data.head())\n",
    "\n",
    "                st.write(\"### D_Target シートのデータ\")\n",
    "                st.dataframe(target_data.head())\n",
    "\n",
    "            else:\n",
    "                st.error(\"アップロードされたファイルはExcel形式ではありません。\")\n",
    "\n",
    "            st.write(\"読込終了\")\n",
    "\n",
    "\n",
    "\n",
    "            # 「無し」という値を空白に置き換え、必須番組データと除外データを作成\n",
    "            exc_data = limit_data.copy()\n",
    "            must_data = limit_data.copy()\n",
    "\n",
    "            values_to_replace_exc = [15, 30, 60, 120, 240]\n",
    "            values_to_replace_must = [\"無し\"]\n",
    "            exc_data.replace(values_to_replace_exc, '', inplace=True)  # 除外の0-1データ\n",
    "            must_data.replace(values_to_replace_must, '', inplace=True)  # 必須番組の割り振り秒数データ\n",
    "\n",
    "            # ブランド名のリストを取得\n",
    "            brand_names = brand_data.index.tolist()\n",
    "            #ブランドの割り付け情報が入ってる\n",
    "            temp_brand_data = limit_data.copy()\n",
    "            temp_brand_data = temp_brand_data.drop(columns=[col for col in limit_data.columns if 'Cost/30' in col])\n",
    "            temp_brand_data = temp_brand_data.drop(columns=[col for col in limit_data.columns if 'P_seconds' in col])\n",
    "            temp_brand_data = temp_brand_data.drop(columns=[col for col in limit_data.columns if 'Program' in col])\n",
    "\n",
    "            #番組のコストと秒数\n",
    "            temp_program_data = limit_data[['Cost/30', 'P_seconds']]\n",
    "\n",
    "            # 各ブランドの当初の予算を保存\n",
    "            allocated_brand_data = brand_data.copy()  # 割り付けに使うブランドごとの予算\n",
    "            initial_brand_budget = allocated_brand_data.copy()  # 割り付け前の初期予算\n",
    "            used_brand_budget = pd.DataFrame(0, index=brand_names, columns=[120, 60, 30, 15])  # 割り当てられた予算のデータフレーム\n",
    "\n",
    "            # 視聴データを保持する辞書（ターゲット層に基づく長さを設定）\n",
    "            brand_view_data = {}\n",
    "            # target_dataがDataFrameであることを仮定\n",
    "            brand_target = target_data\n",
    "\n",
    "            for brand_column in brand_names:\n",
    "                # ブランドのターゲット年齢範囲と性別を取得\n",
    "                target_age_range = brand_target.loc[brand_column, ['Low', 'High']]  # 年齢範囲\n",
    "                target_gender = brand_target.loc[brand_column, 'Gender']  # 性別\n",
    "\n",
    "                # ターゲット層に一致する視聴データを絞り込み\n",
    "                if target_gender == 'MF':\n",
    "                    # 「MF」ターゲットの場合、性別に関係なくすべての視聴者を選択\n",
    "                    filtered_view_data = view_data[\n",
    "                        (view_data['Age'] >= target_age_range[0]) & \n",
    "                        (view_data['Age'] <= target_age_range[1])\n",
    "                    ]\n",
    "                else:\n",
    "                    # 指定された性別と年齢範囲に基づいて絞り込み\n",
    "                    filtered_view_data = view_data[\n",
    "                        (view_data['Age'] >= target_age_range[0]) & \n",
    "                        (view_data['Age'] <= target_age_range[1]) & \n",
    "                        (view_data['Gender'] == target_gender)\n",
    "                    ]\n",
    "                \n",
    "                # ターゲット層に一致する視聴データのインデックス長さを取得\n",
    "                filtered_index = filtered_view_data.index\n",
    "                print(len(filtered_index))\n",
    "                # ターゲット層に基づいて視聴データを初期化\n",
    "                brand_view_data[brand_column] = pd.Series([False] * len(filtered_index), index=filtered_index)\n",
    "\n",
    "\n",
    "            # 割り当て結果を記録するデータフレーム\n",
    "            allocated_program_data = pd.DataFrame(columns=['Program_code', 'Brand', 'Allocated_seconds', 'Allocated_cost', 'New_Viewers'])\n",
    "\n",
    "            #アロケのした後のフレーム\n",
    "            fin_data = limit_data.copy()\n",
    "            #====================================================\n",
    "\n",
    "            st.write(\"設定終了\")\n",
    "\n",
    "            #セル3================================================\n",
    "            # brand_targetがDataFrameで、'Brand'がインデックスとして設定されている場合\n",
    "            for brand_column in temp_brand_data.columns:\n",
    "                print(f\"\\n--- {brand_column} の処理 ---\")\n",
    "\n",
    "                for index, value in temp_brand_data[brand_column].items():\n",
    "                    if value == \"無し\" or pd.isna(value):\n",
    "                        continue  # \"無し\"や NaN の場合はスキップ\n",
    "\n",
    "                    if value in [15, 30, 60, 120, 240]:  # valueが秒数として有効か確認\n",
    "                        program_code, date = index  # 複合キーから program_code と date を取り出す\n",
    "                        \n",
    "                        print(program_code)\n",
    "\n",
    "                        # 番組のコストと秒数を取得\n",
    "                        program_cost = temp_program_data.loc[(program_code, date), 'Cost/30']\n",
    "                        program_seconds = temp_program_data.loc[(program_code, date), 'P_seconds']\n",
    "\n",
    "                        # ブランドの秒数を減らす\n",
    "                        brand_seconds = value  # temp_brand_dataの値がそのまま秒数と仮定\n",
    "                        program_seconds_remaining = program_seconds - brand_seconds  # 残り秒数を計算\n",
    "\n",
    "                        # 番組の秒数を更新する（必要ならtemp_program_dataに反映）\n",
    "                        temp_program_data.loc[(program_code, date), 'P_seconds'] = program_seconds_remaining\n",
    "\n",
    "                        # ブランド名と今回の秒数に基づいてコストを取得\n",
    "                        brand_cost = allocated_brand_data.loc[brand_column, value]  # ブランド名と秒数が一致するコストを取得\n",
    "                        \n",
    "                        # ブランドの秒数とコストを取得\n",
    "                        brand_seconds = value  # temp_brand_dataの値がそのまま秒数と仮定\n",
    "                        allocated_cost = program_cost * (brand_seconds / 30)  # コストを計算\n",
    "\n",
    "                        allocated_brand_data.at[brand_column, value] -= allocated_cost\n",
    "                        new_cost = allocated_brand_data.loc[brand_column, value]\n",
    "\n",
    "                        # 試聴データをターゲット層（年齢・性別）に基づいて絞り込み\n",
    "                        target_age_range = brand_target.loc[brand_column, ['Low', 'High']]  # 年齢範囲を取得\n",
    "                        target_gender = brand_target.loc[brand_column,'Gender']  # 例: 'Female'\n",
    "\n",
    "                        if target_gender == 'MF':\n",
    "                            # 「MF」ターゲットの場合、性別に関係なくすべての視聴者を選択\n",
    "                            filtered_view_data = view_data[\n",
    "                                (view_data['Age'] >= target_age_range[0]) & \n",
    "                                (view_data['Age'] <= target_age_range[1])\n",
    "                            ]\n",
    "                        else:\n",
    "                            # 指定された性別と年齢範囲に基づいて絞り込み\n",
    "                            filtered_view_data = view_data[\n",
    "                                (view_data['Age'] >= target_age_range[0]) & \n",
    "                                (view_data['Age'] <= target_age_range[1]) & \n",
    "                                (view_data['Gender'] == target_gender)\n",
    "                            ]\n",
    "\n",
    "                        # 視聴データを取得（重複を除いた新しい視聴者のみ）\n",
    "                        past_viewer = brand_view_data[brand_column].copy()\n",
    "                        brand_view_data[brand_column] |= filtered_view_data[program_code]\n",
    "                        viewer_add = sum(brand_view_data[brand_column]) - sum(past_viewer)\n",
    "\n",
    "                        # 情報を表示\n",
    "                        \"\"\"\n",
    "                        print(f\"Brand: {brand_column}, 秒数: {value}\")\n",
    "                        print(f\"対応するコスト: {brand_cost}\")\n",
    "                        print(f\"Program: {program_code}, Date: {date}\")\n",
    "                        print(f\"Program Cost/30: {program_cost}, Program Seconds: {program_seconds}\")\n",
    "                        print(f\"Brand Allocated Seconds: {brand_seconds}, Brand Allocated Cost: {allocated_cost}\")\n",
    "                        print(f\"新しいブランド予算: {new_cost}\")\n",
    "                        print(f\"残り番組秒数: {program_seconds_remaining}\")\n",
    "                        print(\"-\" * 50)\n",
    "                        print(f\"元の視聴データ: {sum(past_viewer)}\")\n",
    "                        print(f\"新規視聴データ: {sum(brand_view_data[brand_column])}\")\n",
    "                        print(f\"新規獲得視聴者: {viewer_add}\")\n",
    "                        print(f\"サンプル数: {len(brand_view_data[brand_column])}\")\n",
    "                        \"\"\"\n",
    "\n",
    "                        # 新しい行のデータを作成\n",
    "                        new_row = pd.DataFrame({\n",
    "                            'Program_code': [program_code],\n",
    "                            'Brand': [brand_column],\n",
    "                            'Allocated_seconds': [brand_seconds],\n",
    "                            'Allocated_cost': [allocated_cost],\n",
    "                            'New_Viewers': [viewer_add]\n",
    "                        })\n",
    "                        \n",
    "                        # 既存のデータフレームに新しい行を追加する\n",
    "                        allocated_program_data = pd.concat([allocated_program_data, new_row], ignore_index=True)\n",
    "            #====================================================\n",
    "           \n",
    "            st.write(\"必須終了\")\n",
    "\n",
    "            #セル4================================================\n",
    "            pd.set_option('mode.chained_assignment', None)  # チェーンされた代入の警告を無視\n",
    "            import warnings\n",
    "            warnings.simplefilter(action='ignore', category=FutureWarning)\n",
    "\n",
    "\n",
    "            # view_track DataFrameの初期化\n",
    "            view_track = pd.DataFrame(columns=['Brand', 'Round', 'New_Viewers', 'Total_Viewers', 'Reach_Rate'])\n",
    "\n",
    "            # 初期化\n",
    "            seconds_priorities = sorted(brand_data.columns, reverse=True)\n",
    "            round_number = 0  # ラウンドカウンタ\n",
    "            all_brands_done = False  # 全てのブランドの割り付けが終わったかを確認するフラグ\n",
    "            allocated_program_data = pd.DataFrame(columns=['Program_code', 'Brand', 'date', 'Allocated_seconds', 'Allocated_cost', 'New_Viewers'])\n",
    "\n",
    "            # 割り当て済みの番組コードと日付の組み合わせを保存するためのセット\n",
    "            assigned_programs = set()\n",
    "\n",
    "            # 割り付け可能なブランドがある限り繰り返すループ\n",
    "            while not all_brands_done:\n",
    "                print(f\"\\n--- ラウンド {round_number} ---\")\n",
    "                \n",
    "                all_brands_done = True  # すべてのブランドが完了したか確認するために一旦Trueにする\n",
    "\n",
    "                # 各ブランドごとに割り当てを行う\n",
    "                for brand in brand_names:\n",
    "                    program_assigned = False  # フラグを初期化\n",
    "                    brand_new_viewers = 0  # このラウンドでの新規視聴者数を初期化\n",
    "\n",
    "                    # ターゲット層（年齢・性別）に基づいて視聴データを絞り込み\n",
    "                    target_age_range = brand_target.loc[brand, ['Low', 'High']]  # 年齢範囲\n",
    "                    target_gender = brand_target.loc[brand, 'Gender']  # 性別\n",
    "\n",
    "                    # ターゲット層に一致する視聴データを絞り込む\n",
    "                    if target_gender == 'MF':\n",
    "                        # 「MF」ターゲットの場合、性別に関係なくすべての視聴者を選択\n",
    "                        filtered_view_data = view_data[\n",
    "                            (view_data['Age'] >= target_age_range[0]) & \n",
    "                            (view_data['Age'] <= target_age_range[1])\n",
    "                        ]\n",
    "                    else:\n",
    "                        # 指定された性別と年齢範囲に基づいて絞り込み\n",
    "                        filtered_view_data = view_data[\n",
    "                            (view_data['Age'] >= target_age_range[0]) & \n",
    "                            (view_data['Age'] <= target_age_range[1]) & \n",
    "                            (view_data['Gender'] == target_gender)\n",
    "                        ]\n",
    "\n",
    "                    # 優先する秒数の順にチェック\n",
    "                    for seconds in seconds_priorities:\n",
    "                        if program_assigned:  # 番組が割り当てられた場合は次のブランドに移行\n",
    "                            break\n",
    "\n",
    "                        brand_rest_cost = allocated_brand_data.at[brand, seconds]\n",
    "                        program_cost_arr = temp_program_data['Cost/30'] * (seconds / 30)\n",
    "                        program_seconds_arr = temp_program_data['P_seconds']\n",
    "\n",
    "                        if (program_cost_arr > brand_rest_cost).all():\n",
    "                            print(f\"{brand}の{seconds}は予算上限に達しています。\")\n",
    "                            continue\n",
    "\n",
    "                        if (program_seconds_arr < seconds).all():\n",
    "                            print(f\"{brand}の{seconds}に割り当てられる番組秒数がありません。\")\n",
    "                            continue\n",
    "\n",
    "                        # もし予算が残っていれば番組を割り当てる\n",
    "                        if allocated_brand_data.at[brand, seconds] > 0:\n",
    "                            best_program = None\n",
    "                            best_new_viewers = 0\n",
    "                            best_allocated_seconds = 0\n",
    "                            best_date = None\n",
    "\n",
    "                            temp_df = pd.DataFrame()\n",
    "                            past_viewer = brand_view_data[brand].copy()  # ここでコピーを取る\n",
    "\n",
    "                            # 最適な番組を選ぶための処理\n",
    "                            for index, value in temp_brand_data[brand].items():\n",
    "                                program_code, date = index\n",
    "\n",
    "                                # 既に割り当てられた番組・日付の組み合わせをチェック\n",
    "                                if (program_code, date, brand) in assigned_programs:\n",
    "                                    print(f\"{brand} に対して、プログラム {program_code}, 日付 {date} は既に割り当て済みです。\")\n",
    "                                    continue\n",
    "\n",
    "                                # \"無し\" または視聴データがNaNでない場合はスキップ\n",
    "                                if value == \"無し\" or not pd.isna(value):\n",
    "                                    continue\n",
    "\n",
    "                                # 番組のコストと秒数を取得\n",
    "                                program_cost = temp_program_data.at[(program_code, date), 'Cost/30'] * (seconds / 30)\n",
    "                                program_seconds = temp_program_data.at[(program_code, date), 'P_seconds']\n",
    "\n",
    "                                # 割り当て可能な秒数を確認\n",
    "                                if program_seconds < seconds:\n",
    "                                    continue\n",
    "\n",
    "                                # コスト確認\n",
    "                                if allocated_brand_data.at[brand, seconds] < program_cost:\n",
    "                                    continue\n",
    "\n",
    "                                # 過去の視聴者数を保持し、新たな視聴者数を計算\n",
    "                                if program_code in filtered_view_data.columns:\n",
    "                                    new_viewers = filtered_view_data[program_code]\n",
    "                                    target_cost = new_viewers.sum() / program_cost\n",
    "\n",
    "                                    # 既存の視聴者データと結合（視聴した人を1とする場合）\n",
    "                                    temp_brand_view_data = past_viewer | new_viewers\n",
    "                                    viewer_add = temp_brand_view_data.sum() - past_viewer.sum()\n",
    "                                    viewer_add_per_cost = viewer_add / program_cost\n",
    "                                else:\n",
    "                                    viewer_add = 0\n",
    "\n",
    "                                if viewer_add <= 0:\n",
    "                                    continue\n",
    "\n",
    "                                # 番組を追加\n",
    "                                temp_data = pd.DataFrame({\n",
    "                                    'program_code': [program_code],\n",
    "                                    'date': [date],\n",
    "                                    'viewer_add': [viewer_add],\n",
    "                                    'viewer_add_per_cost': [viewer_add_per_cost],\n",
    "                                    'target_cost': [target_cost]\n",
    "                                })\n",
    "\n",
    "                                temp_df = pd.concat([temp_df, temp_data], ignore_index=True)\n",
    "\n",
    "                            # temp_dfから最適な番組を選ぶ\n",
    "                            if not temp_df.empty:\n",
    "                                if mode == \"reach\":\n",
    "                                    # リーチが最大のものを選ぶ\n",
    "                                    best_row = temp_df.loc[temp_df[\"viewer_add\"].idxmax()]\n",
    "                                    if best_row[\"viewer_add\"] > 0:  # 新規視聴者数が正の場合のみ割り付け\n",
    "                                        best_program = best_row[\"program_code\"]\n",
    "                                        best_date = best_row[\"date\"]\n",
    "                                        best_new_viewers = best_row[\"viewer_add\"]\n",
    "\n",
    "                                elif mode == \"reach_cost\":\n",
    "                                    # リーチ増分に対するコスト効率が最も高いものを選ぶ\n",
    "                                    best_row = temp_df.loc[temp_df[\"viewer_add_per_cost\"].idxmin()]\n",
    "                                    if best_row[\"viewer_add\"] > 0:  # 新規視聴者数が正の場合のみ割り付け\n",
    "                                        best_program = best_row[\"program_code\"]\n",
    "                                        best_date = best_row[\"date\"]\n",
    "                                        best_new_viewers = best_row[\"viewer_add\"]\n",
    "\n",
    "                                elif mode == \"target_cost\":\n",
    "                                    # target_costが最も小さいものを選ぶ（必ず割り付け）\n",
    "                                    best_row = temp_df.loc[temp_df[\"target_cost\"].idxmin()]\n",
    "                                    best_program = best_row[\"program_code\"]\n",
    "                                    best_date = best_row[\"date\"]\n",
    "                                    best_new_viewers = best_row[\"viewer_add\"]\n",
    "                                    print(\"tgコストで選んでる\")\n",
    "\n",
    "                            # 最適な番組が見つかった場合の処理\n",
    "                            if best_program and best_date is not None:\n",
    "                                # 割り当てた番組の処理（コストの減算や視聴者データの更新など）\n",
    "                                best_program_cost = temp_program_data.at[(best_program, best_date), 'Cost/30'] * (seconds / 30)\n",
    "                                allocated_brand_data.at[brand, seconds] -= best_program_cost\n",
    "                                temp_program_data.at[(best_program, best_date), 'P_seconds'] -= seconds\n",
    "                                new_viewers = filtered_view_data[best_program]  # 視聴データの更新\n",
    "                                brand_view_data[brand] = past_viewer | new_viewers  # 既存の視聴者データと結合（視聴した人を1とする場合）\n",
    "                                total_viewers = brand_view_data[brand].sum()\n",
    "                                sample_num = len(brand_view_data[brand_column])\n",
    "                                view_rate = total_viewers / sample_num\n",
    "                                \n",
    "                                # 割り当て結果を表示\n",
    "                                print(f\"最適な番組: {best_program} を {brand} に割り当てます。\")\n",
    "                                print(f\"累計到達数:{total_viewers}, 新規到達数: {best_new_viewers}, 到達率: {view_rate}\")\n",
    "                                print(f\"残り予算: {allocated_brand_data.at[brand, seconds]}, 残り秒数: {temp_program_data.at[(best_program, best_date), 'P_seconds']}\")\n",
    "                                print(f\"更新前サンプル数: {len(past_viewer)}\")\n",
    "                                print(f\"追加サンプル数: {len(past_viewer)}\")\n",
    "                                print(f\"更新後サンプル数: {len(brand_view_data[brand_column])}\")\n",
    "                                \n",
    "                                # 新しい行のデータを作成\n",
    "                                new_row = pd.DataFrame({\n",
    "                                    'Program_code': [best_program],\n",
    "                                    'Brand': [brand],\n",
    "                                    'date': [best_date],\n",
    "                                    'Allocated_seconds': [seconds],\n",
    "                                    'Allocated_cost': [best_program_cost],\n",
    "                                    'New_Viewers': [best_new_viewers]\n",
    "                                })\n",
    "\n",
    "                                # 既存のデータフレームに新しい行を追加する\n",
    "                                allocated_program_data = pd.concat([allocated_program_data, new_row], ignore_index=True)\n",
    "\n",
    "                                # 同じ番組、日付、ブランドの組み合わせを追跡するためにセットに追加\n",
    "                                assigned_programs.add((best_program, best_date, brand))\n",
    "\n",
    "                                # ブランドごとの新規視聴者数を累積\n",
    "                                brand_new_viewers += best_new_viewers\n",
    "\n",
    "                                # 割り当てが完了したのでフラグをTrueにし、次のブランドに移る\n",
    "                                program_assigned = True\n",
    "                                all_brands_done = False  # 割り当てが行われたら次のラウンドも行う\n",
    "\n",
    "                                fin_data.at[(best_program, best_date), brand] = seconds\n",
    "                                print(\"割り付け成功！\")\n",
    "                                break  # 1ラウンドで1番組のみ割り当てるので、次のブランドに移る\n",
    "                            else:\n",
    "                                print(f\"{brand} の {seconds}秒枠で適切な番組が見つかりませんでした。次の秒数枠に移行します。\")\n",
    "\n",
    "                    # このブランドのラウンド終了時にリーチ率を計算\n",
    "                    if program_assigned:\n",
    "                        # view_trackにデータを追加\n",
    "                        view_track = pd.concat([view_track, pd.DataFrame({\n",
    "                            'Brand': [brand],\n",
    "                            'Round': [round_number],\n",
    "                            'New_Viewers': [brand_new_viewers],\n",
    "                            'Total_Viewers': [total_viewers],\n",
    "                            'Reach_Rate': [view_rate]\n",
    "                        })], ignore_index=True)\n",
    "\n",
    "                # 全ブランドで番組が割り当てられない場合はループを終了\n",
    "                if all_brands_done:\n",
    "                    print(\"すべてのブランドの割り当てが完了しました。\")\n",
    "                    break\n",
    "\n",
    "                # ラウンドをカウントアップ\n",
    "                round_number += 1\n",
    "\n",
    "            # 最終割り当て結果を表示\n",
    "            print(\"最終割り当て結果:\")\n",
    "            print(allocated_program_data)\n",
    "\n",
    "            # リーチ率の追跡結果を表示\n",
    "            print(\"リーチ率の追跡結果:\")\n",
    "            print(view_track)\n",
    "\n",
    "            #====================================================\n",
    "           \n",
    "            st.write(\"割り付け終了\")\n",
    "\n",
    "            #セル5================================================\n",
    "            # 最終的な視聴率データフレームを初期化\n",
    "            fin_view_rate_list = pd.DataFrame(columns=['Brand', 'Total_Viewers', 'Reach_Rate'])\n",
    "\n",
    "            # 各ブランドの視聴者数とリーチ率を計算\n",
    "            for brand in brand_names:\n",
    "                total_viewers = brand_view_data[brand].sum()  # ブランドの総視聴者数\n",
    "                sample_num = len(brand_view_data[brand])\n",
    "                view_rate = (total_viewers / sample_num) if sample_num > 0 else 0  # リーチ率の計算\n",
    "                print(f\"{brand} サンプル：{sample_num}リーチ{total_viewers}\")\n",
    "\n",
    "                # データを追加\n",
    "                fin_view_rate_list = pd.concat([fin_view_rate_list, pd.DataFrame({\n",
    "                    'Brand': [brand],\n",
    "                    'Total_Viewers': [total_viewers],\n",
    "                    'Reach_Rate': [view_rate]\n",
    "                })], ignore_index=True)\n",
    "\n",
    "            # 最終結果を表示\n",
    "            print(fin_view_rate_list)\n",
    "            #====================================================\n",
    "           \n",
    "            st.title(\"データ成形終了\")\n",
    "\n",
    "            #セル6================================================\n",
    "            # Excel出力関数\n",
    "            def create_excel_file():\n",
    "                output = BytesIO()\n",
    "                with pd.ExcelWriter(output, engine='openpyxl') as writer:\n",
    "                    fin_data.to_excel(writer, sheet_name='program×brand', index=True)\n",
    "                    allocated_program_data.to_excel(writer, sheet_name='allocated_program_data', index=True)\n",
    "                    view_track.to_excel(writer, sheet_name='view_track', index=True)\n",
    "                    fin_view_rate_list.to_excel(writer, sheet_name='fin_view_rate_list', index=True)\n",
    "                    allocated_brand_data.to_excel(writer, sheet_name='allocated_brand_cost', index=True)\n",
    "                output.seek(0)\n",
    "                return output\n",
    "            \n",
    "            excel_file = create_excel_file()\n",
    "            \n",
    "            # Streamlitアプリ本体\n",
    "            st.title(\"Excelファイル出力\")\n",
    "            # ボタンでExcelファイルを生成・ダウンロード\n",
    "            st.download_button(\n",
    "                label=\"Excelファイルをダウンロード\",\n",
    "                data=excel_file,\n",
    "                file_name=\"output.xlsx\",\n",
    "                mime=\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\"\n",
    "            )\n",
    "\n",
    "        except Exception as e:\n",
    "            st.error(f\"ファイルを読み込む際にエラーが発生しました: {e}\")\n",
    "\n",
    "#tab5用の初期化、実行に関わる関数==========================\n",
    "def initialize_session_state():\n",
    "    \"\"\"セッションステートの初期化\"\"\"\n",
    "    defaults = {\n",
    "        \"current_step\": \"モード選択\",  # 初期ステップ\n",
    "        \"uploaded_config_file\": None,  # アップロードされた条件ファイル\n",
    "        \"uploaded_view_file\": None, #アップロードされた視聴データファイル\n",
    "        \"processed_data\": None,  # 処理されたデータ\n",
    "        \"allocated_cost_data\": None,  # 残コストデータ\n",
    "        \"allocated_program_data\": None,  # 割り付けログ\n",
    "        \"mode\": \"\",  # モード選択\n",
    "        \"step_status\": {\n",
    "            \"モード選択\": True,  # 最初のステップをTrue\n",
    "            \"条件ファイルアップロード\": False,\n",
    "            \"Viewファイルアップロード\": False,\n",
    "            \"実行\": False,\n",
    "        },\n",
    "        # ログイン情報（例: ユーザー情報）はここで保持\n",
    "        \"user_info\": st.session_state.get(\"user_info\", None),  # ログイン情報を保持\n",
    "    }\n",
    "    for key, value in defaults.items():\n",
    "        if key not in st.session_state:\n",
    "            st.session_state[key] = value\n",
    "\n",
    "def reset_app():\n",
    "    \"\"\"特定のセッションステート項目のみをリセット\"\"\"\n",
    "    keys_to_reset = [\n",
    "        \"current_step\", \n",
    "        \"uploaded_config_file\", \n",
    "        \"uploaded_view_file\",\n",
    "        \"processed_data\", \n",
    "        \"allocated_cost_data\", \n",
    "        \"allocated_program_data\", \n",
    "        \"mode\", \n",
    "        \"step_status\",\n",
    "    ]\n",
    "    for key in keys_to_reset:\n",
    "        if key in st.session_state:\n",
    "            del st.session_state[key]\n",
    "    initialize_session_state()  # 再初期化\n",
    "\n",
    "def display_mode_selection():\n",
    "    \"\"\"モード選択画面\"\"\"\n",
    "    if st.session_state[\"step_status\"][\"モード選択\"]:\n",
    "        st.header(\"モード選択\")\n",
    "        options = [\"\", \"reach_cost\", \"reach\", \"target_cost\"]  # 空欄を追加\n",
    "        st.session_state[\"mode\"] = st.selectbox(\"モードを選択してください\", options)\n",
    "        \n",
    "        if st.session_state[\"mode\"] == \"\":\n",
    "            st.warning(\"モードを選択してください\")\n",
    "        else:\n",
    "            st.write(f\"選択されたモード: {st.session_state['mode']}\")\n",
    "            if st.button(\"条件ファイルアップロードへ\", key=\"to_upload\"):\n",
    "                st.session_state[\"current_step\"] = \"条件ファイルアップロード\"\n",
    "                st.session_state[\"step_status\"][\"条件ファイルアップロード\"] = True\n",
    "\n",
    "def display_config_file_upload():\n",
    "    \"\"\"ファイルアップロード画面\"\"\"\n",
    "    if st.session_state[\"step_status\"][\"条件ファイルアップロード\"]:\n",
    "        st.header(\"条件ファイルアップロード\")\n",
    "        if st.session_state[\"uploaded_config_file\"] is None:\n",
    "            uploaded_config_file = st.file_uploader(\"条件Excelファイルをアップロードしてください\", type=[\"xlsx\"])\n",
    "            if uploaded_config_file is not None:\n",
    "                st.session_state[\"uploaded_config_file\"] = uploaded_config_file\n",
    "        else:\n",
    "            st.write(\"既にアップロードされた条件ファイルがあります。\")\n",
    "            st.write(f\"アップロード済み条件ファイル: {st.session_state['uploaded_config_file'].name}\")\n",
    "\n",
    "        if st.session_state[\"uploaded_config_file\"] is not None:\n",
    "            if st.button(\"Viewファイルアップロードへ\", key=\"to_execute_config\"):\n",
    "                st.session_state[\"current_step\"] = \"Viewファイルアップロード\"\n",
    "                st.session_state[\"step_status\"][\"Viewファイルアップロード\"] = True\n",
    "\n",
    "def display_view_file_upload():\n",
    "    \"\"\"ファイルアップロード画面\"\"\"\n",
    "    if st.session_state[\"step_status\"][\"Viewファイルアップロード\"]:\n",
    "        st.header(\"Viewファイルアップロード\")\n",
    "        if st.session_state[\"uploaded_view_file\"] is None:\n",
    "            uploaded_view_file = st.file_uploader(\"CSV Viewファイルをアップロードしてください\", type=[\"csv\"])\n",
    "            if uploaded_view_file is not None:\n",
    "                st.session_state[\"uploaded_view_file\"] = uploaded_view_file\n",
    "        else:\n",
    "            st.write(\"既にアップロードされたViewファイルがあります。\")\n",
    "            st.write(f\"アップロード済みViewファイル: {st.session_state['uploaded_view_file'].name}\")\n",
    "\n",
    "        if st.session_state[\"uploaded_view_file\"] is not None:\n",
    "            if st.button(\"次へ\", key=\"to_execute_view\"):\n",
    "                st.session_state[\"current_step\"] = \"実行\"\n",
    "                st.session_state[\"step_status\"][\"実行\"] = True\n",
    "\n",
    "\n",
    "def display_execution():\n",
    "    \"\"\"実行画面\"\"\"\n",
    "    if st.session_state[\"step_status\"][\"実行\"]:\n",
    "        st.header(\"最適化の実行\")\n",
    "        st.write(f\"選択されたモード: {st.session_state['mode']}\")\n",
    "\n",
    "        # config_fileとview_fileがアップロードされている場合のみ処理を実行\n",
    "        if st.session_state[\"processed_data\"] is None and st.session_state[\"uploaded_config_file\"] is not None and st.session_state[\"uploaded_view_file\"] is not None:\n",
    "            st.write(\"処理を実行しています...\")\n",
    "\n",
    "            # configファイル（Excel）を読み込む\n",
    "            bytes_data_config = st.session_state[\"uploaded_config_file\"].read()  # 正しく読み込む\n",
    "            config_data = pd.read_excel(BytesIO(bytes_data_config), sheet_name=None)\n",
    "\n",
    "            # 各シートを取得\n",
    "            limit_data = config_data['A_Limit'].set_index(['Program_code', 'date'])\n",
    "            brand_data = config_data['B_Brand'].set_index('Brand')\n",
    "            target_data = config_data['D_Target'].set_index('Brand')\n",
    "\n",
    "            # viewファイル（CSV）からデータを読み込む\n",
    "            bytes_data_view = st.session_state[\"uploaded_view_file\"].read()  # 正しく読み込む\n",
    "            view_data = pd.read_csv(BytesIO(bytes_data_view))\n",
    "\n",
    "            # 必要な処理を行う（例: インデックスを設定）\n",
    "            view_data = view_data.set_index('Sample')\n",
    "\n",
    "            # データを表示\n",
    "            st.write(\"A_Limit シートのデータ\")\n",
    "            st.dataframe(limit_data.head())\n",
    "            st.write(\"B_Brand シートのデータ\")\n",
    "            st.dataframe(brand_data.head())\n",
    "            st.write(\"D_Target シートのデータ\")\n",
    "            st.dataframe(target_data.head())\n",
    "            st.write(\"C_View シートのデータ\")\n",
    "            st.dataframe(view_data.head())\n",
    "\n",
    "            # 「無し」という値を空白に置き換え、必須番組データと除外データを作成\n",
    "            exc_data = limit_data.copy()\n",
    "            must_data = limit_data.copy()\n",
    "\n",
    "            values_to_replace_exc = [15, 30, 60, 120, 240]\n",
    "            values_to_replace_must = [\"無し\"]\n",
    "            exc_data.replace(values_to_replace_exc, '', inplace=True)  # 除外の0-1データ\n",
    "            must_data.replace(values_to_replace_must, '', inplace=True)  # 必須番組の割り振り秒数データ\n",
    "\n",
    "            # ブランド名のリストを取得\n",
    "            brand_names = brand_data.index.tolist()\n",
    "            #ブランドの割り付け情報が入ってる\n",
    "            temp_brand_data = limit_data.copy()\n",
    "            temp_brand_data = temp_brand_data.drop(columns=[col for col in limit_data.columns if 'Cost/30' in col])\n",
    "            temp_brand_data = temp_brand_data.drop(columns=[col for col in limit_data.columns if 'P_seconds' in col])\n",
    "            temp_brand_data = temp_brand_data.drop(columns=[col for col in limit_data.columns if 'Program' in col])\n",
    "\n",
    "            #番組のコストと秒数\n",
    "            temp_program_data = limit_data[['Cost/30', 'P_seconds']]\n",
    "\n",
    "            # 各ブランドの当初の予算を保存\n",
    "            allocated_brand_data = brand_data.copy()  # 割り付けに使うブランドごとの予算\n",
    "            initial_brand_budget = allocated_brand_data.copy()  # 割り付け前の初期予算\n",
    "            used_brand_budget = pd.DataFrame(0, index=brand_names, columns=[120, 60, 30, 15])  # 割り当てられた予算のデータフレーム\n",
    "\n",
    "            # 視聴データを保持する辞書（ターゲット層に基づく長さを設定）\n",
    "            brand_view_data = {}\n",
    "            # target_dataがDataFrameであることを仮定\n",
    "            brand_target = target_data\n",
    "\n",
    "            for brand_column in brand_names:\n",
    "                # ブランドのターゲット年齢範囲と性別を取得\n",
    "                target_age_range = brand_target.loc[brand_column, ['Low', 'High']]  # 年齢範囲\n",
    "                target_gender = brand_target.loc[brand_column, 'Gender']  # 性別\n",
    "\n",
    "                # ターゲット層に一致する視聴データを絞り込み\n",
    "                if target_gender == 'MF':\n",
    "                    # 「MF」ターゲットの場合、性別に関係なくすべての視聴者を選択\n",
    "                    filtered_view_data = view_data[\n",
    "                        (view_data['Age'] >= target_age_range[0]) & \n",
    "                        (view_data['Age'] <= target_age_range[1])\n",
    "                    ]\n",
    "                else:\n",
    "                    # 指定された性別と年齢範囲に基づいて絞り込み\n",
    "                    filtered_view_data = view_data[\n",
    "                        (view_data['Age'] >= target_age_range[0]) & \n",
    "                        (view_data['Age'] <= target_age_range[1]) & \n",
    "                        (view_data['Gender'] == target_gender)\n",
    "                    ]\n",
    "                \n",
    "                # ターゲット層に一致する視聴データのインデックス長さを取得\n",
    "                filtered_index = filtered_view_data.index\n",
    "                print(len(filtered_index))\n",
    "                # ターゲット層に基づいて視聴データを初期化\n",
    "                brand_view_data[brand_column] = pd.Series([False] * len(filtered_index), index=filtered_index)\n",
    "\n",
    "\n",
    "            # 割り当て結果を記録するデータフレーム\n",
    "            allocated_program_data = pd.DataFrame(columns=['Program_code', 'Brand', 'Allocated_seconds', 'Allocated_cost', 'New_Viewers','Total_Viewers','Potential','Reach_Rate','Round'])\n",
    "\n",
    "            #アロケのした後のフレーム\n",
    "            fin_data = limit_data.copy()\n",
    "            #====================================================\n",
    "\n",
    "            st.write(\"設定終了\")\n",
    "\n",
    "            #セル3================================================\n",
    "            # brand_targetがDataFrameで、'Brand'がインデックスとして設定されている場合\n",
    "            # 空のプレースホルダを作成（このエリアがログ表示エリアになります）\n",
    "            log_config_placeholder = st.empty()\n",
    "            # 初期のログ内容\n",
    "            log_config = \"\"\n",
    "            for brand_column in temp_brand_data.columns:\n",
    "                print(f\"\\n--- {brand_column} の処理 ---\")\n",
    "\n",
    "                for index, value in temp_brand_data[brand_column].items():\n",
    "                    if value == \"無し\" or pd.isna(value):\n",
    "                        continue  # \"無し\"や NaN の場合はスキップ\n",
    "\n",
    "                    if value in [15, 30, 60, 120, 240]:  # valueが秒数として有効か確認\n",
    "                        program_code, date = index  # 複合キーから program_code と date を取り出す\n",
    "                        \n",
    "                        print(program_code)\n",
    "\n",
    "                        # 番組のコストと秒数を取得\n",
    "                        program_cost = temp_program_data.loc[(program_code, date), 'Cost/30']\n",
    "                        program_seconds = temp_program_data.loc[(program_code, date), 'P_seconds']\n",
    "\n",
    "                        # ブランドの秒数を減らす\n",
    "                        brand_seconds = value  # temp_brand_dataの値がそのまま秒数と仮定\n",
    "                        program_seconds_remaining = program_seconds - brand_seconds  # 残り秒数を計算\n",
    "\n",
    "                        # 番組の秒数を更新する（必要ならtemp_program_dataに反映）\n",
    "                        temp_program_data.loc[(program_code, date), 'P_seconds'] = program_seconds_remaining\n",
    "\n",
    "                        # ブランド名と今回の秒数に基づいてコストを取得\n",
    "                        brand_cost = allocated_brand_data.loc[brand_column, value]  # ブランド名と秒数が一致するコストを取得\n",
    "                        \n",
    "                        # ブランドの秒数とコストを取得\n",
    "                        brand_seconds = value  # temp_brand_dataの値がそのまま秒数と仮定\n",
    "                        allocated_cost = program_cost * (brand_seconds / 30)  # コストを計算\n",
    "\n",
    "                        # 1. インデックスが一致しているか確認\n",
    "                        print(allocated_brand_data.index)  # インデックスを確認\n",
    "                        print(brand_column, value)  # 使用しているインデックスも確認\n",
    "\n",
    "                        # 2. データ型を確認し、必要なら変換\n",
    "                        if not isinstance(allocated_cost, (int, float)):\n",
    "                            allocated_cost = float(allocated_cost)\n",
    "                        \n",
    "                        # ブランドの予算を減らす\n",
    "                        allocated_brand_data.at[brand_column, value] -= allocated_cost\n",
    "                        new_cost = allocated_brand_data.loc[brand_column, value]\n",
    "\n",
    "                        # 試聴データをターゲット層（年齢・性別）に基づいて絞り込み\n",
    "                        target_age_range = brand_target.loc[brand_column, ['Low', 'High']]  # 年齢範囲を取得\n",
    "                        target_gender = brand_target.loc[brand_column,'Gender']  # 例: 'Female'\n",
    "\n",
    "                        if target_gender == 'MF':\n",
    "                            # 「MF」ターゲットの場合、性別に関係なくすべての視聴者を選択\n",
    "                            filtered_view_data = view_data[\n",
    "                                (view_data['Age'] >= target_age_range[0]) & \n",
    "                                (view_data['Age'] <= target_age_range[1])\n",
    "                            ]\n",
    "                        else:\n",
    "                            # 指定された性別と年齢範囲に基づいて絞り込み\n",
    "                            filtered_view_data = view_data[\n",
    "                                (view_data['Age'] >= target_age_range[0]) & \n",
    "                                (view_data['Age'] <= target_age_range[1]) & \n",
    "                                (view_data['Gender'] == target_gender)\n",
    "                            ]\n",
    "\n",
    "                        # 視聴データを取得（重複を除いた新しい視聴者のみ）\n",
    "                        past_viewer = brand_view_data[brand_column].copy()\n",
    "                        brand_view_data[brand_column] |= filtered_view_data[program_code]\n",
    "                        viewer_add = sum(brand_view_data[brand_column]) - sum(past_viewer)\n",
    "                        Reach_rate = brand_view_data[brand_column] / len(brand_view_data[brand_column])\n",
    "\n",
    "                        log_config += f\"=====================================================================================\"\n",
    "                        log_config += f\"{brand_column}の{value}秒を{program_code}:{date}に{program_cost}円で割り付け\\n\"\n",
    "                        log_config += f\"{brand_column}の{value}秒の元予算{brand_cost}から残り予算{new_cost}へ\\n\"\n",
    "                        log_config += f\"{brand_column}のリーチ数は{sum(past_viewer)}から{sum(brand_view_data[brand_column])}へ\\n\"\n",
    "\n",
    "                        # ログ表示を更新\n",
    "                        log_config_placeholder.text_area(\"必須番組処理ログ\", log_config, height=300)\n",
    "\n",
    "                        print(f\"Brand: {brand_column}, 秒数: {value}\")\n",
    "                        print(f\"対応するコスト: {brand_cost}\")\n",
    "                        print(f\"Program: {program_code}, Date: {date}\")\n",
    "                        print(f\"Program Cost/30: {program_cost}, Program Seconds: {program_seconds}\")\n",
    "                        print(f\"Brand Allocated Seconds: {brand_seconds}, Brand Allocated Cost: {allocated_cost}\")\n",
    "                        print(f\"新しいブランド予算: {new_cost}\")\n",
    "                        print(f\"残り番組秒数: {program_seconds_remaining}\")\n",
    "                        print(\"-\" * 50)\n",
    "                        print(f\"元の視聴データ: {sum(past_viewer)}\")\n",
    "                        print(f\"新規視聴データ: {sum(brand_view_data[brand_column])}\")\n",
    "                        print(f\"新規獲得視聴者: {viewer_add}\")\n",
    "                        print(f\"サンプル数: {len(brand_view_data[brand_column])}\")\n",
    "\n",
    "\n",
    "                        # 新しい行のデータを作成\n",
    "                        new_row = pd.DataFrame({\n",
    "                            'Program_code': [program_code],\n",
    "                            'Brand': [brand_column],\n",
    "                            'Allocated_seconds': [brand_seconds],\n",
    "                            'Allocated_cost': [allocated_cost],\n",
    "                            'New_Viewers': [viewer_add],\n",
    "                            'Total_Viewers': [brand_view_data[brand_column]],\n",
    "                            'Potential': [len(brand_view_data[brand_column])],\n",
    "                            'Reach_Rate': [Reach_rate],\n",
    "                            'Round':[None]\n",
    "                        })\n",
    "\n",
    "                        #'Program_code', 'Brand', 'Allocated_seconds', 'Allocated_cost', 'New_Viewers','Total_Viewers','Potential','Reach_Rate','Round'])\n",
    "                        \n",
    "                        # 既存のデータフレームに新しい行を追加する\n",
    "                        allocated_program_data = pd.concat([allocated_program_data, new_row], ignore_index=True)\n",
    "            #====================================================\n",
    "        \n",
    "            st.write(\"必須終了\")\n",
    "\n",
    "            #セル4================================================\n",
    "            pd.set_option('mode.chained_assignment', None)  # チェーンされた代入の警告を無視\n",
    "            import warnings\n",
    "            warnings.simplefilter(action='ignore', category=FutureWarning)\n",
    "\n",
    "\n",
    "            # view_track DataFrameの初期化\n",
    "            view_track = pd.DataFrame(columns=['Brand', 'Round', 'New_Viewers', 'Total_Viewers', 'Reach_Rate'])\n",
    "\n",
    "            # 初期化\n",
    "            seconds_priorities = sorted(brand_data.columns, reverse=True)\n",
    "            round_number = 0  # ラウンドカウンタ\n",
    "            all_brands_done = False  # 全てのブランドの割り付けが終わったかを確認するフラグ\n",
    "            allocated_program_data = pd.DataFrame(columns=['Program_code', 'Brand', 'date', 'Allocated_seconds', 'Allocated_cost', 'New_Viewers'])\n",
    "\n",
    "            # 割り当て済みの番組コードと日付の組み合わせを保存するためのセット\n",
    "            assigned_programs = set()\n",
    "\n",
    "            log_opt_placeholder = st.empty()\n",
    "            # 初期のログ内容\n",
    "            log_opt = \"\"\n",
    "            # 割り付け可能なブランドがある限り繰り返すループ\n",
    "            while not all_brands_done:\n",
    "                print(f\"\\n--- ラウンド {round_number} ---\")\n",
    "                \n",
    "                all_brands_done = True  # すべてのブランドが完了したか確認するために一旦Trueにする\n",
    "\n",
    "                # 各ブランドごとに割り当てを行う\n",
    "                for brand in brand_names:\n",
    "                    program_assigned = False  # フラグを初期化\n",
    "                    brand_new_viewers = 0  # このラウンドでの新規視聴者数を初期化\n",
    "\n",
    "                    # ターゲット層（年齢・性別）に基づいて視聴データを絞り込み\n",
    "                    target_age_range = brand_target.loc[brand, ['Low', 'High']]  # 年齢範囲\n",
    "                    target_gender = brand_target.loc[brand, 'Gender']  # 性別\n",
    "\n",
    "                    # ターゲット層に一致する視聴データを絞り込む\n",
    "                    if target_gender == 'MF':\n",
    "                        # 「MF」ターゲットの場合、性別に関係なくすべての視聴者を選択\n",
    "                        filtered_view_data = view_data[\n",
    "                            (view_data['Age'] >= target_age_range[0]) & \n",
    "                            (view_data['Age'] <= target_age_range[1])\n",
    "                        ]\n",
    "                    else:\n",
    "                        # 指定された性別と年齢範囲に基づいて絞り込み\n",
    "                        filtered_view_data = view_data[\n",
    "                            (view_data['Age'] >= target_age_range[0]) & \n",
    "                            (view_data['Age'] <= target_age_range[1]) & \n",
    "                            (view_data['Gender'] == target_gender)\n",
    "                        ]\n",
    "\n",
    "                    # 優先する秒数の順にチェック\n",
    "                    for seconds in seconds_priorities:\n",
    "                        if program_assigned:  # 番組が割り当てられた場合は次のブランドに移行\n",
    "                            break\n",
    "\n",
    "                        brand_rest_cost = allocated_brand_data.at[brand, seconds]\n",
    "                        program_cost_arr = temp_program_data['Cost/30'] * (seconds / 30)\n",
    "                        program_seconds_arr = temp_program_data['P_seconds']\n",
    "\n",
    "                        if (program_cost_arr > brand_rest_cost).all():\n",
    "                            print(f\"{brand}の{seconds}は予算上限に達しています。\")\n",
    "                            continue\n",
    "\n",
    "                        if (program_seconds_arr < seconds).all():\n",
    "                            print(f\"{brand}の{seconds}に割り当てられる番組秒数がありません。\")\n",
    "                            continue\n",
    "\n",
    "                        # もし予算が残っていれば番組を割り当てる\n",
    "                        if allocated_brand_data.at[brand, seconds] > 0:\n",
    "                            best_program = None\n",
    "                            best_new_viewers = 0\n",
    "                            best_allocated_seconds = 0\n",
    "                            best_date = None\n",
    "\n",
    "                            temp_df = pd.DataFrame()\n",
    "                            past_viewer = brand_view_data[brand].copy()  # ここでコピーを取る\n",
    "\n",
    "                            # 最適な番組を選ぶための処理\n",
    "                            for index, value in temp_brand_data[brand].items():\n",
    "                                program_code, date = index\n",
    "\n",
    "                                # 既に割り当てられた番組・日付の組み合わせをチェック\n",
    "                                if (program_code, date, brand) in assigned_programs:\n",
    "                                    print(f\"{brand} に対して、プログラム {program_code}, 日付 {date} は既に割り当て済みです。\")\n",
    "                                    continue\n",
    "\n",
    "                                # \"無し\" または視聴データがNaNでない場合はスキップ\n",
    "                                if value == \"無し\" or not pd.isna(value):\n",
    "                                    continue\n",
    "\n",
    "                                # 番組のコストと秒数を取得\n",
    "                                program_cost = temp_program_data.at[(program_code, date), 'Cost/30'] * (seconds / 30)\n",
    "                                program_seconds = temp_program_data.at[(program_code, date), 'P_seconds']\n",
    "\n",
    "                                # 割り当て可能な秒数を確認\n",
    "                                if program_seconds < seconds:\n",
    "                                    continue\n",
    "\n",
    "                                # コスト確認\n",
    "                                if allocated_brand_data.at[brand, seconds] < program_cost:\n",
    "                                    continue\n",
    "\n",
    "                                # 過去の視聴者数を保持し、新たな視聴者数を計算\n",
    "                                if program_code in filtered_view_data.columns:\n",
    "                                    new_viewers = filtered_view_data[program_code]\n",
    "                                    target_cost = new_viewers.sum() / program_cost\n",
    "\n",
    "                                    # 既存の視聴者データと結合（視聴した人を1とする場合）\n",
    "                                    temp_brand_view_data = past_viewer | new_viewers\n",
    "                                    viewer_add = temp_brand_view_data.sum() - past_viewer.sum()\n",
    "                                    viewer_add_per_cost = viewer_add / program_cost\n",
    "                                else:\n",
    "                                    viewer_add = 0\n",
    "\n",
    "                                #if viewer_add <= 0:\n",
    "                                    #continue\n",
    "\n",
    "                                #新しいviewrが増えないとtempdfに追加されてないから増えないんだ\n",
    "\n",
    "                                # 番組を追加\n",
    "                                temp_data = pd.DataFrame({\n",
    "                                    'program_code': [program_code],\n",
    "                                    'date': [date],\n",
    "                                    'viewer_add': [viewer_add],\n",
    "                                    'viewer_add_per_cost': [viewer_add_per_cost],\n",
    "                                    'target_cost': [target_cost]\n",
    "                                })\n",
    "\n",
    "                                temp_df = pd.concat([temp_df, temp_data], ignore_index=True)\n",
    "\n",
    "                            mode = str(st.session_state[\"mode\"])\n",
    "                            print(mode)\n",
    "\n",
    "                            # temp_dfから最適な番組を選ぶ\n",
    "                            if not temp_df.empty:\n",
    "                                print(\"えへ\")\n",
    "                                if mode == \"reach\":\n",
    "                                    print(\"リーチになってる\")\n",
    "                                    # リーチが最大のものを選ぶ\n",
    "                                    best_row = temp_df.loc[temp_df[\"viewer_add\"].idxmax()]\n",
    "                                    if best_row[\"viewer_add\"] > 0:  # 新規視聴者数が正の場合のみ割り付け\n",
    "                                        best_program = best_row[\"program_code\"]\n",
    "                                        best_date = best_row[\"date\"]\n",
    "                                        best_new_viewers = best_row[\"viewer_add\"]\n",
    "\n",
    "                                elif mode == \"reach_cost\":\n",
    "                                    print(\"best\")\n",
    "                                    # リーチ増分に対するコスト効率が最も高いものを選ぶ\n",
    "                                    best_row = temp_df.loc[temp_df[\"viewer_add_per_cost\"].idxmin()]\n",
    "                                    if best_row[\"viewer_add\"] > 0:  # 新規視聴者数が正の場合のみ割り付け\n",
    "                                        best_program = best_row[\"program_code\"]\n",
    "                                        best_date = best_row[\"date\"]\n",
    "                                        best_new_viewers = best_row[\"viewer_add\"]\n",
    "\n",
    "                                elif mode == \"target_cost\":\n",
    "                                    print(\"ターゲットコストを選択できてる\")\n",
    "                                    # target_costが最も小さいものを選ぶ（必ず割り付け）\n",
    "                                    best_row = temp_df.loc[temp_df[\"target_cost\"].idxmin()]\n",
    "                                    best_program = best_row[\"program_code\"]\n",
    "                                    best_date = best_row[\"date\"]\n",
    "                                    best_new_viewers = best_row[\"viewer_add\"]\n",
    "                                    print(best_program)\n",
    "\n",
    "                            print(\"ここじゃない\")\n",
    "\n",
    "                            # 最適な番組が見つかった場合の処理\n",
    "                            if best_program and best_date is not None:\n",
    "                                # 割り当てた番組の処理（コストの減算や視聴者データの更新など）\n",
    "                                best_program_cost = temp_program_data.at[(best_program, best_date), 'Cost/30'] * (seconds / 30)\n",
    "                                old_cost = allocated_brand_data.at[brand, seconds]\n",
    "                                allocated_brand_data.at[brand, seconds] -= best_program_cost\n",
    "                                temp_program_data.at[(best_program, best_date), 'P_seconds'] -= seconds\n",
    "                                new_viewers = filtered_view_data[best_program]  # 視聴データの更新\n",
    "                                brand_view_data[brand] = past_viewer | new_viewers  # 既存の視聴者データと結合（視聴した人を1とする場合）\n",
    "                                total_viewers = brand_view_data[brand].sum()\n",
    "                                sample_num = len(brand_view_data[brand_column])\n",
    "                                view_rate = total_viewers / sample_num\n",
    "                                \n",
    "                                # 割り当て結果を表示\n",
    "                                print(f\"最適な番組: {best_program} を {brand} に割り当てます。\")\n",
    "                                print(f\"累計到達数:{total_viewers}, 新規到達数: {best_new_viewers}, 到達率: {view_rate}\")\n",
    "                                print(f\"残り予算: {allocated_brand_data.at[brand, seconds]}, 残り秒数: {temp_program_data.at[(best_program, best_date), 'P_seconds']}\")\n",
    "                                print(f\"更新前サンプル数: {len(past_viewer)}\")\n",
    "                                print(f\"追加サンプル数: {len(past_viewer)}\")\n",
    "                                print(f\"更新後サンプル数: {len(brand_view_data[brand_column])}\")\n",
    "\n",
    "                                log_opt += f\"================================================================================\"\n",
    "                                log_opt += f\"{brand}の{seconds}秒を{best_program}:{best_date}に{best_program_cost}円で割り付け\\n\"\n",
    "                                log_opt += f\"{brand}の{seconds}秒の元予算{old_cost}から残り予算{allocated_brand_data.at[brand, seconds]}へ\\n\"\n",
    "                                log_opt += f\"{brand}のリーチ数は{sum(past_viewer)}から{total_viewers}へ\\n\"\n",
    "                                # ログ表示を更新\n",
    "                                log_opt_placeholder.text_area(\"最適番組処理ログ\", log_opt, height=300)\n",
    "                                \n",
    "                                # 新しい行のデータを作成\n",
    "                                new_row = pd.DataFrame({\n",
    "                                    'Program_code': [best_program],\n",
    "                                    'Brand': [brand],\n",
    "                                    'date': [best_date],\n",
    "                                    'Allocated_seconds': [seconds],\n",
    "                                    'Allocated_cost': [best_program_cost],\n",
    "                                    'New_Viewers': [best_new_viewers],\n",
    "                                    'Total_Viewers': [total_viewers],\n",
    "                                    'Potential': [sample_num],\n",
    "                                    'Reach_Rate': [view_rate],\n",
    "                                    'Round':[round_number]\n",
    "                                })\n",
    "\n",
    "                                # 既存のデータフレームに新しい行を追加する\n",
    "                                allocated_program_data = pd.concat([allocated_program_data, new_row], ignore_index=True)\n",
    "\n",
    "                                # 同じ番組、日付、ブランドの組み合わせを追跡するためにセットに追加\n",
    "                                assigned_programs.add((best_program, best_date, brand))\n",
    "\n",
    "                                # ブランドごとの新規視聴者数を累積\n",
    "                                brand_new_viewers += best_new_viewers\n",
    "\n",
    "                                # 割り当てが完了したのでフラグをTrueにし、次のブランドに移る\n",
    "                                program_assigned = True\n",
    "                                all_brands_done = False  # 割り当てが行われたら次のラウンドも行う\n",
    "\n",
    "                                fin_data.at[(best_program, best_date), brand] = seconds\n",
    "                                print(\"割り付け成功！\")\n",
    "                                break  # 1ラウンドで1番組のみ割り当てるので、次のブランドに移る\n",
    "                            else:\n",
    "                                print(f\"{brand} の {seconds}秒枠で適切な番組が見つかりませんでした。次の秒数枠に移行します。\")\n",
    "\n",
    "                    # このブランドのラウンド終了時にリーチ率を計算\n",
    "                    if program_assigned:\n",
    "                        # view_trackにデータを追加\n",
    "                        view_track = pd.concat([view_track, pd.DataFrame({\n",
    "                            'Brand': [brand],\n",
    "                            'Round': [round_number],\n",
    "                            'New_Viewers': [brand_new_viewers],\n",
    "                            'Total_Viewers': [total_viewers],\n",
    "                            'Reach_Rate': [view_rate]\n",
    "                        })], ignore_index=True)\n",
    "\n",
    "                # 全ブランドで番組が割り当てられない場合はループを終了\n",
    "                if all_brands_done:\n",
    "                    print(\"すべてのブランドの割り当てが完了しました。\")\n",
    "                    break\n",
    "\n",
    "                # ラウンドをカウントアップ\n",
    "                round_number += 1\n",
    "\n",
    "            # 最終割り当て結果を表示\n",
    "            print(\"最終割り当て結果:\")\n",
    "            print(allocated_program_data)\n",
    "\n",
    "            # リーチ率の追跡結果を表示\n",
    "            print(\"リーチ率の追跡結果:\")\n",
    "            print(view_track)\n",
    "\n",
    "            #====================================================\n",
    "        \n",
    "            st.write(\"割り付け終了\")\n",
    "\n",
    "            #セル5================================================\n",
    "            # 最終的な視聴率データフレームを初期化\n",
    "            fin_view_rate_list = pd.DataFrame(columns=['Brand', 'Total_Viewers', 'Reach_Rate'])\n",
    "\n",
    "            # 各ブランドの視聴者数とリーチ率を計算\n",
    "            for brand in brand_names:\n",
    "                total_viewers = brand_view_data[brand].sum()  # ブランドの総視聴者数\n",
    "                sample_num = len(brand_view_data[brand])\n",
    "                view_rate = (total_viewers / sample_num) if sample_num > 0 else 0  # リーチ率の計算\n",
    "                print(f\"{brand} サンプル：{sample_num}リーチ{total_viewers}\")\n",
    "\n",
    "                # データを追加\n",
    "                fin_view_rate_list = pd.concat([fin_view_rate_list, pd.DataFrame({\n",
    "                    'Brand': [brand],\n",
    "                    'Total_Viewers': [total_viewers],\n",
    "                    'Reach_Rate': [view_rate]\n",
    "                })], ignore_index=True)\n",
    "\n",
    "            # 最終結果を表示\n",
    "            st.write(fin_view_rate_list)\n",
    "            #====================================================\n",
    "\n",
    "            st.session_state[\"processed_data\"] = fin_data #素材を割り付けた状態のデータ\n",
    "            st.session_state[\"allocated_cost_data\"] = allocated_brand_data #ブランドの残コストデータ\n",
    "            st.session_state[\"allocated_program_data\"] = allocated_program_data #割り付けのログ\n",
    "\n",
    "        # 結果を表示\n",
    "        if st.session_state[\"processed_data\"] is not None:\n",
    "            st.write(\"割り付け結果:\")\n",
    "            st.write(st.session_state[\"processed_data\"])\n",
    "            st.write(\"ブランド残予算:\")\n",
    "            st.write(st.session_state[\"allocated_cost_data\"])\n",
    "            st.write(\"割り付けトラッキングデータ:\")\n",
    "            st.write(st.session_state[\"allocated_program_data\"])\n",
    "\n",
    "def tab5():\n",
    "    \"\"\"アプリケーションのメイン関数\"\"\"\n",
    "    initialize_session_state()\n",
    "\n",
    "    # リセットボタン\n",
    "    if st.button(\"リセット\", key=\"reset\"):\n",
    "        reset_app()\n",
    "\n",
    "    # 各ステップの画面を表示（過去のステップも残す）\n",
    "    display_mode_selection()\n",
    "    display_config_file_upload()\n",
    "    display_view_file_upload()\n",
    "    display_execution()\n",
    "\n",
    "#Streamlitを実行する関数\n",
    "def main():\n",
    "    if login():\n",
    "        tabs = st.sidebar.radio(\"メニュー\", [\"Curve数式予測\", \"STL分解\", \"Logistic回帰\", \"TIME最適化\"])\n",
    "\n",
    "        # ログアウトボタン\n",
    "        if st.button(\"ログアウト\"):\n",
    "            st.session_state.logged_in = False\n",
    "            st.experimental_rerun()  # ログアウト後にページを再実行してログイン画面に戻る\n",
    "\n",
    "        if tabs == \"Curve数式予測\":\n",
    "            tab1()\n",
    "        elif tabs == \"STL分解\":\n",
    "            tab2()\n",
    "        elif tabs == \"Logistic回帰\":\n",
    "            tab3()\n",
    "        elif tabs == \"TIME最適化\":\n",
    "            tab5()\n",
    "\n",
    "\n",
    "#実行コード\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "221fce8e-efb4-4e48-86ca-86b368bcfaf7",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:base] *",
   "language": "python",
   "name": "conda-base-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
